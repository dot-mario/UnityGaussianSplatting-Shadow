● 문제 분석 결과

  원본 렌더링 파이프라인과 그림자 텍스처 파이프라인을 비교 분석한 결과,
   다음과 같은 주요 차이점과 문제점을 발견했습니다:

  1. 행렬 사용의 차이점

  원본 파이프라인 (CSCalcViewData):
  - UNITY_MATRIX_VP와 _MatrixMV를 사용
  - 뷰 프로젝션은 Unity의 내장 행렬을 직접 사용

  그림자 파이프라인 (CSCalcLightViewData):
  - _LightViewMatrix와 _LightProjMatrix를 별도로 전달받음
  - _LightModelViewMatrix도 함께 사용 (이는 _LightViewMatrix * 
  _MatrixObjectToWorld)

  2. 주요 문제점: CalcCovariance2D 함수 호출의 차이

  원본 (line 243-246):
  float3 cov2d = CalcCovariance2D(splat.pos, cov3d0, cov3d1,
      _MatrixMV,
      UNITY_MATRIX_P,
      _VecScreenParams);

  그림자 (line 954-957):
  float3 cov2d_elements = 
  CalcCovariance2D(sharedLightData.splatLocalPos, 
  sharedLightData.cov3d0, sharedLightData.cov3d1,
      _LightModelViewMatrix,
      _LightProjMatrix,
      _LightScreenParams);

  3. 문제의 핵심: CalcCovariance2D 함수 내부

  CalcCovariance2D 함수를 보면 (line 56-90):
  - 첫 번째 파라미터로 받은 worldPos를 matrixV로 변환하여 뷰 공간
  좌표를 구함
  - 그런데 그림자 파이프라인에서는 _LightModelViewMatrix를 전달하는데,
  이는 이미 모델 변환이 포함된 행렬임

  4. 좌표 변환의 중복 문제

  그림자 파이프라인에서:
  1. sharedLightData.splatLocalPos는 로컬 좌표
  2. _LightModelViewMatrix는 이미 _LightViewMatrix * 
  _MatrixObjectToWorld
  3. CalcCovariance2D 내부에서 다시 matrixV로 변환하면 모델 변환이
  중복됨

  5. 해결 방안

● Update Todos
  ⎿  ☒ 원본 렌더링 파이프라인 파일 분석 (RenderGaussianSplats.shader, 
       CSCalcViewData)
     ☒ 그림자 파이프라인 파일 분석 (ShadowCasterSplat.shader, 
       CSCalcLightViewData)
     ☒ 좌표계 변환 로직 빔교 (ViewMatrix, ProjMatrix 적용 부분)
     ☒ 컴퓨트 셰이더 내 행렬 연산 검증
     ☒ 문제점 진단 및 해결방안 제시

● 해결 방안

  문제는 CSCalcLightViewData에서 CalcCovariance2D를 호출할 때 잘못된
  파라미터를 전달하는 것입니다:

  현재 문제가 있는 코드:
  float3 cov2d_elements = CalcCovariance2D(
      sharedLightData.splatLocalPos,  // 로컬 좌표
      sharedLightData.cov3d0, 
      sharedLightData.cov3d1,
      _LightModelViewMatrix,  // 이미 모델 변환이 포함된 행렬
      _LightProjMatrix,
      _LightScreenParams
  );

  해결책 1: CalcCovariance2D에 월드 좌표와 뷰 행렬만 전달
  float3 cov2d_elements = CalcCovariance2D(
      sharedLightData.centerWorldPos,  // 월드 좌표 사용
      sharedLightData.cov3d0, 
      sharedLightData.cov3d1,
      _LightViewMatrix,  // 뷰 행렬만 사용
      _LightProjMatrix,
      _LightScreenParams
  );

  해결책 2: C# 코드에서 행렬 전달 수정
  // 현재 코드 (line 257)
  cmd.SetComputeMatrixParam(m_SplatUtilitiesCS,
  s_LightModelViewMatrixID,
      currentLightViewMatrix *
  m_GaussianSplatRenderer.transform.localToWorldMatrix);

  // 수정안 - 뷰 행렬만 전달
  cmd.SetComputeMatrixParam(m_SplatUtilitiesCS, s_LightViewMatrixID,
  currentLightViewMatrix);

  가장 간단한 해결책은 CSCalcLightViewData 커널에서
  _LightModelViewMatrix 대신 _LightViewMatrix를 사용하는 것입니다. 이미
   sharedLightData.centerWorldPos에 월드 좌표가 계산되어 있으므로, 원본
   파이프라인과 동일한 방식으로 처리하면 됩니다.